\documentclass[preprint]{acm_proc_article-sp}
\usepackage{ucs,textcomp,url,xspace,graphicx,color}
\usepackage[nolineno]{lgrind}
\usepackage[bf]{caption2}
\usepackage[numbers]{natbib}
\usepackage[utf8]{inputenc}
\ifx\pdfoutput\undefined\else
  \usepackage[
    pdfpagemode=None,
    pdftitle={MetaOCaml Server Pages},
    pdfsubject={Web Publishing as Staged Computation},
    pdfauthor={Christopher League}
  ]{hyperref}
\fi
\input{fonts}
\def\MOC{MetaOCaml\xspace}
\hyphenation{Meta-OCaml data-base Slash-dot}
\def\quote{\list{}{\leftmargin1.4em\rightmargin1em}\item[]}
\newcommand{\myfig}[3]{%
  \begin{figure}[tbp]%
    #3%
    \caption{#2}%
    \label{fig:#1}%
  \end{figure}}
\newcommand{\screenshot}[2]{%
  \myfig{#1}{#2}
  {\centering%
    \includegraphics[width=20pc,keepaspectratio]{#1}}}
\newcommand{\gnuplot}[2]{%
  \myfig{#1}{#2}{\input{#1}}}
\newcommand{\listing}[2]{\lagrind[tbp]{#1}{#2}{lst:#1}}

\newcounter{listing}
\setcounter{listing}{0}
\makeatletter
\def\ext@listing{lol}
\def\fnum@listing{Listing\nobreakspace\thelisting}
\makeatother
\newcommand{\mylst}[2]{%
  \captionof{listing}{\textbf{#1.} #2}%
  \label{lst:#1}%
  \lgrindfile{#1}}
\newcommand{\mylstf}[2]{%
  \begin{figure}[tbp!]%
    \lgrindfile{#1}%
    \captionof{listing}{\textbf{#1.} #2}%
    \label{lst:#1}%
  \end{figure}}

\title{\MOC Server Pages:}
\subtitle{Web Publishing as Staged Computation}
\numberofauthors{1}
\author{
  \alignauthor Christopher League\\
  \affaddr{Long Island University · Computer Science}\\
  \affaddr{1 University Plaza · Brooklyn, NY 11201}\\
  \email{christopher.league@liu.edu}}
%\conferenceinfo{\MOC Workshop}{October 2004, Vancouver}
%\CopyrightYear{2004}
%\toappear{Submitted to the \MOC Workshop (Vancouver,
%  2004).}

\begin{document}
\maketitle
\begin{abstract}
  Modern dynamic web services are really computer programs.
  Some parts of these programs run off-line, others run
  server-side on each request, and still others run within
  the browser.  In other words, web publishing is
  \emph{staged computation,} either for better performance,
  or because certain resources are available in one stage
  but not another.  Unfortunately, the various web
  programming languages target one stage only.  This is a
  tremendous opportunity for multi-stage languages in
  general, and for \MOC in particular.
  
  We present the design of \MOC Server Pages.  Unlike
  other languages in its genre, the embedded \MOC code
  blocks may be annotated with staging information, so that
  the programmer may safely and precisely control which
  computation occurs in which stage.  A prototype web
  server, written in OCaml, supports web sites with both
  static and dynamic content.  We provide several sample
  programs and demonstrate the performance gains won using
  multi-stage programming.
\end{abstract}
\category{D.3.2}{Programming Languages}{Language
  Classifications}[Specialized application languages]
\category{H.3.5}{Information Storage and Retrieval}{Online Information
  Services}[Web-based services]

\section{Motivation}
\label{sec:intro}

In their infancy (ca.~1993), web sites were little more than
clickable FTP sites with in-line images.  They enabled
distribution of static documents, but did little to enhance
collaboration or create a sense of community.  In contrast,
today's users expect most web sites to offer sophisticated
services and to permit endless personalization.  In 2004,
even a strictly personal web site is expected to incorporate
user-contributed content such as comments and ratings.

To provide such features, web sites contain custom computer
programs.  \citet{greenspun99panda}, in his insightful web
publishing guide book, describes the situation like this:

\begin{quote}
  You needn’t turn your site into a program just because the
  body of material that you are publishing is changing.
  Sites like Yahoo, for example, are sets of static files
  that are periodically generated by programs grinding
  through a dynamic database.  With this sort of
  arrangement, the site inevitably lags behind the database,
  but you can handle millions of hits a day without a major
  investment in computer hardware, custom software, or
  thought.\par If you want to make a collaborative site,
  however, then at least some of your web pages will have to
  be computer programs.  Pages that process user submissions
  have to add user-supplied data to your web server’s disk.
  Pages that display user submissions have to look through a
  database on your server before delivering the relevant
  contributions.~\cite[page 271]{greenspun99panda}
\end{quote}

In some notable ways, programming for the web is different
from programming in other domains.  Interaction design is
more of a challenge: in part because HTTP is stateless, but
also because users want to hit the `back' button and to set
bookmarks into the middle of
a carefully designed sequence of dialogs.%
\footnote{\citet{queinnec00influence} and
  \citet{graunke01programming} examine language-based
  approaches to solving this particular
  problem.} %
And unlike with shrink-wrapped applications, on the web it
is possible (though not always desirable) to ``go live''
immediately with a new fix or feature.

Nevertheless, there is at least one dictum of program design
that we cannot escape on the web: \emph{performance
  matters.}  As a web publisher, visitors are your bread and
butter.  But will your servers and scripts be ready for the
day that your site is featured on prime time television, or
on \texttt{slashdot.org}?  If tens of thousands of potential
users drop by to find a sluggish (or dead) server, most of
them will never return.

This happens so often to sites featured on Slashdot---a
``news for nerds'' discussion site---that it has come to be
known as the \emph{Slashdot effect:} ``a site that might be
designed to handle a few hundred hits per day can suddenly
find itself handling that many a
second.''~\cite{turner03slashdot}~ Although some ISPs have
bandwidth limitations, Slashdot creator Rob Malda says most
sites that fall suffer from poor planning and architecture:
\begin{quote}
  The problem is, if you have any sort of complicated code
  on your page, that’s what kills people. I generally think
  that sites are not dying because they fill their pipe, but
  because they have poorly written code.
  
  As a general rule, anybody who has a pretty good
  understanding of web design, they’ve done a good job of
  learning what information to cache. What information needs
  to be pregenerated. So when you’re actually loading a
  page, even if it’s a complicated page that looks dynamic
  and custom, on the back end of that, what they’re really
  doing is putting together a bunch of puzzle pieces that
  have been pregenerated, and making the simplest, quickest
  decisions they possibly can.~\cite{turner03slashdot}
\end{quote}

Both of the preceding quotes point (informally) to the idea
of \emph{staging} the computation performed by a web
service.  Indeed, web publishing is an application area that
is naturally staged;\footnote{Nevertheless, it seems the
  literature on meta-programming has not yet acknowledged
  web services as a potential application area, although
  \citet{sheard01accomp} does
  mention \emph{mobile code.}} %
to wit:
\begin{enumerate}
\item Content (text, images, programs, etc.) created
  off-line is uploaded to the server---the \emph{publish}
  stage;
  
\item A user's browser requests content, which is
  transferred from server to client---the \emph{serve}
  stage; and finally
  
\item The content is rendered within the user's
  browser---the \emph{display} stage.
\end{enumerate}
At \emph{each} stage there is an opportunity for computation
to take place.  Consider the example of a conference
calendar, such as the one illustrated in
figure~\ref{fig:confcal}.  After specifying your areas of
interest (perhaps using the ACM classifications), the server
delivers a table of matching conferences, with dates,
locations, deadlines, and links to conference web sites.
Events remain in the table until a few weeks after they
occur, but deadlines that have passed are marked in red.
You may click on any column header to change the sort order.
The next time you visit, the server remembers your
preferences.  Perhaps it even sends you email to remind you
of upcoming submission and registration deadlines.

\screenshot{confcal}{A simple conference calendar, implemented as a
  PHP script that connects to a PostgreSQL database.  Not as
  sophisticated as the service described in the text.}

Now, how might this conference service be staged?  Can
anything be computed off-line (at the \emph{publish} stage)?
Yes!  Since this page is probably part of a much larger site
(whose structure does not change every day), the menus and
other navigation aids can be laid out in advance.  We will
not know which conferences to display until the user
presents some identification (in the form of a `cookie'),
but since the conference data changes infrequently, it may
help to prepare the text of each row in advance.

During the \emph{serve} stage, we look up the user's topic
preferences, and ship out just the matching rows.  We delay
sorting the table until the \emph{display} stage.  The user
ought to be able to adjust the sort criteria without any
further communication with the server.  What about marking
past dates in red?  If this is also delayed until display,
then the code could be cached client-side for long periods
of time, yet still behave dynamically.

At this point, we should emphasize the importance of
\emph{profiling} in developing scalable web services.  This
particular design for the conference calendar may not be
optimal, depending on the relative speeds of the CPU,
memory, database, network, and disk.  Rather, our aim is to
provide a single language in which the various staging
possibilities can be expressed naturally.

This is in stark contrast to the status quo, where each
system targets one stage only.  The Website Meta Language
(WML) \cite{engelschall-wml} is an ``off-line HTML
generation toolkit'' designed for the \emph{publish} stage.
But many other programs (and countless ad-hoc scripts) spit
out HTML pages: think of \LaTeX2HTML.  Google
reports surprisingly many
programs\footnote{\url{http://google.com/search?q=gedcom+generate+html}}
for creating family tree web sites from genealogy database
files; these count as publish-stage tools.

The \emph{serve} stage is well-served by the ``server page''
languages, including JSP~\cite{sun-jsp},
ASP~\cite{microsoft-asp},
MSP~\cite{elsman03web}, and
PHP~\cite{bakken04php}.  The CGI protocol~\cite{w3c-cgi}
addresses the \emph{serve} stage, as do the embedded
interpreters (such as \texttt{mod\_perl} and
\texttt{mod\_python} for Apache) that exist to ameliorate some
of the overhead of CGI.
%%
There is, relatively, a paucity of languages that operate
client-side (\emph{display} stage), probably due to the
difficulty of securing an installed base of interpreters.
JavaScript~\cite{netscape-javascript} and Java applets are
notable exceptions.

Imagine implementing the conference calendar, as conceived
above, using currently deployed technology: A Perl script
outputs a PHP page which contains JavaScript!  Values are
passed from one stage to the next as strings, and the
programmer must manage all the quoting and persistence
issues by hand.

We present ``\MOC server pages,'' a new domain-specific
language for web applications programming.  It leverages the
staging annotations of \MOC~\cite{calcagno03meta,taha00metaml}
to provide safe and precise control over the each stage of the
computation.  We have implemented the system in two parts: our
translator transforms the server page language into a \MOC
module, which then can be incorporated into our multi-threaded
HTTP 1.1 server (also written in \MOC).  The scalability
gained by staging certain applications is stunning.

The next section sketches the design and translation of \MOC
server pages, and section~\ref{sec:eg} includes some non-trivial
examples.  The server implementation is decribed in
section~\ref{sec:impl}.  Performance and scalability are
discussed in section~\ref{sec:perf}

\section{Design}
\label{sec:design}

The general idea of a \emph{server page} language is that we
  write HTML by default, and embed code %
\cd{\Mquote{}like this\Munquote}.
PHP programmers are familiar with this syntax for embedding code, but
in our case, the code itself is written in \MOC.  Here is your first
\MOC server page:
\lgrindfile{first.meta}
and its output:
\begin{quote}
  \textit{Hello,} \textbf{Unhandled exception: Failure("Nice try!")}
\end{quote}
If a code block raises an exception, the message is sent to the
client's browser in bold-face, and the rest of the page is
aborted. 

A very common use of code blocks is to print out (i.e., send to
the browser) the result of evaluating some expression.  The
syntax \cd{\Mquote= e\Munquote} is designated for this task; \cd{e} must
have type \cd{string}.  Alternatively, messages may be formatted
with \cd{printf} by placing the format string immediately after
the code delimiter: \lgrindfile{pi.meta}
\begin{quote}
  ........ $\pi$ ÷ 008 is 0.3927
\end{quote}
In a departure from the standard OCaml syntax for \cd{printf}, the
arguments are comma-delimited.  This way, fewer parentheses are
required when using the escape or lift operators on the arguments.

One more kind of code delimiter is used for \emph{declarations;}
these are lifted to the top of your program, and evaluated during
the publishing stage:
%%
\lgrindfile{perm.meta}
\begin{quote}
Permissions on current directory are 0755
\end{quote}

Once published, this output will never change!  The \cd{stat}
call is executed only once, not on each request.

\subsection{Review of staging annotations}

\MOC augments OCaml with just three annotations, to indicate how
programs are to be staged.  Brackets \cd{\Mbegincode like
  these\Mendcode} construct future-stage computation.  The code within
is not executed \emph{now,} but just returned, as a code value that can be
run later.  

Within brackets, the splice or escape operator \cd{\Msplice e} may
appear.  It interrupts the code construction to execute the expression
\cd{e} (in the current stage) and splice its result into the
future-stage computation.  Thus, \cd{e} is required to return code of
the proper type.

To compute and splice in a regular (non-code) value, we define a
function \cd{{\KWfont let} lift x = \Mbegincode x\Mendcode}; this
takes any value and turns it into code.  We use it like this:
\cd{\Mbegincode 2 * \Msplice(lift(3+4))\Mendcode} The addition is
performed immediately (because it is escaped), and the result is
spliced into the code, producing \cd{\Mbegincode 2 * 7\Mendcode}.

Finally, there is an operator \Mrun{} to execute constructed code.
Applying it to the example above, \cd{\Mrun{} \Mbegincode 2 * 7
  \Mendcode} produces \cd{14}.


\subsection{Translation to \MOC}
To see how all this works, let's consider how a \MOC server
page is translated into a proper \MOC program, to be executed
at publish time.  Since the program is executed before any
browser has requested the page, it cannot directly return or
output HTML.  Instead, it will construct and return a \cd{code}
object which is subsequently run on each request (serve stage).
Listing~\ref{lst:trans.meta} shows a sample \MOC server page,
and listing~\ref{lst:trans.ml} contains its translation.

\mylst{trans.meta}{This file demonstrates the various
  kinds of code blocks.}

\mylst{trans.ml}{This is the translation of the
    page in figure~\ref{lst:trans.meta}.  Declarations have
    been lifted, and everything else appears within
    \cd{\Mbegincode brackets\Mendcode}}

Declaration blocks have been lifted to the top; any side effects
contained there are executed when the page is published.  The
constructed code begins with the \cd{{\KWfont let} page} line in
listing~\ref{lst:trans.ml}.  

The \cd{a b c} represent publish-stage arguments (the names are
specified in the \cd{pragma}), whereas \cd{req} and \cd{puts} are
(fixed) serve-stage arguments.  \cd{req} encapsulates the HTTP request
details, including the headers and query arguments.  \cd{puts} is a
function, provided by the server, to 
transmit text across the network to the user's browser.  \cd{arg} is
then defined to look up an argument in the query string of the
request; its type is \cd{string\to string option}.

These are all \emph{serve} (second)
stage values.  It makes no sense to access them in the
\emph{publish} (first) stage, and indeed the \MOC type system
prevents this.

A few finer points to note: the translator discards newlines that
immediately follow code blocks (otherwise,
listing~\ref{lst:trans.ml} would be dotted with %
\cd{puts}~\verb+"\n"+ statements).  It automatically follows
code blocks with either a semi-colon or the {\KWfont in}
keyword, as required.

\subsection{Staged code blocks}
Now that we understand how the server page is assembled into a staged
program, the effects of adding \MOC staging operators to our pages
should be predictable.  Below is a reformulation of the permissions
example, using escape \Msplice{} and \cd{lift} to ensure that
\cd{stat} is called only once.%
\lgrindfile{perm2.meta}%
Still, the \cd{printf} conversion is performed at serve time, so maybe
it is best to pre-generate that as well:%
\lgrindfile{perm3.meta}%
Now, all that remains to execute at serve time is %
\cd{puts "0755"}.  Finally it is possible to splice in serve-stage
parameters at publish time, such as in this count-down example:%
\lgrindfile{count.meta}%
It removes the loop overhead by expanding to a sequence of 99
\cd{puts} statements.

These tiny examples illustrate some of the common uses of the
escape operator, for which we developed syntactic sugar.  The first
set of code blocks we define use the tilde character to indicate that
some part of the enclosed quote is escaped:

\begin{tabular}{l@{\quad$\leadsto$\quad}l}
\cd{\Mquote{\Mtilde} a \Munquote} &
\cd{\Mquote{} \Msplice( a ) \Munquote}
\\
\cd{\Mquote{\Mtilde=} b \Munquote} &
\cd{\Mquote{=} \Msplice( b ) \Munquote}
\\
\cd{\Mquote{\Mtilde}let x = c \Munquote} &
\cd{\Mquote{} let x = \Msplice( c ) \Munquote}
\\
\cd{\Mquote{\Mtilde}\id{"fmt"} d, e, f\Munquote} &
\cd{\Mquote{}\id{"fmt"} \Msplice(d), \Msplice(e), \Msplice(f)\Munquote}
\\
\end{tabular}

where the \cd{a} has type \cd{unit code}; \cd{b} has type
\cd{string code}; and the types of \cd{d,e,f} match the
format string.

It is also common to use the escape with \cd{lift}; this means we are
computing a value immediately and splicing it into the code.  For
these blocks, we use the \Mbang{} character:

\begin{tabular}{{l@{\quad$\leadsto$\quad}l}}
\cd{\Mquote{\Mbang} a \Munquote} &
\cd{\Mquote{} \Msplice(lift( a )) \Munquote}
\\
\cd{\Mquote{\Mbang=} b \Munquote} &
\cd{\Mquote{=} \Msplice(lift( b )) \Munquote}
\\
\cd{\Mquote{\Mbang}let x = c \Munquote} &
\cd{\Mquote{} let x = \Msplice(lift( c )) \Munquote}
\\
\cd{\Mquote{\Mbang}\id{"fmt"} d, e\Munquote} &
\cd{\Mquote{}\id{"fmt"} \Msplice(lift(d)), \Msplice(lift(e))\Munquote}
\\
\end{tabular}

We will see examples of most of these blocks in section~\ref{sec:eg}.

\subsection{Publish-stage arguments}
One last feature in the design of \MOC server pages is the ability
to take publish-stage arguments.  The parameter names are specified to
the translator in a \emph{pragma} declaration, which can appear
anywhere in the code:

(EXPLAIN THIS INSTEAD USING TRANS FIGURE)

Now the code can be instantiated with early parameters in countless
ways.  For example, requesting the URI \id{/longcount} could print a
count-down from 99, while \id{/shortcount} starts at 9 instead.  Both
are generated from the same server page.  Mapping from URIs to
instantiated \MOC code is, for now, an implementation detail
(see section~\ref{sec:impl}).

\section{Examples}
\label{sec:eg}

To explore the expressiveness of this design, we now look at a
series of web services, organized to comprise a small web
site.\footnote{A demo is available at
  \url{http://comsci.liu.edu/metaserv/}}
To give the services a similar look, we developed a site-wide style
sheet, and an OCaml function to generate a navigation bar from a
hierarchical list of page titles and links.  The following bindings are
available site-wide:

\lgrindfile{navspec-sig.ml}
%%
The functions above may be invoked at any stage.  Naturally, if the
page title includes a dynamic argument, then \cd{preamble} will have
to be delayed until theh serve stage.

\subsection{The ubiquitous power function}
\label{sec:eg:power}

\screenshot{power127}{Web browser displaying the result of
  7\textsuperscript{127}.  The URI \texttt{/power127} maps to code
  where the early argument (the exponent) has been set to 127, and the
  late argument (\texttt{x}, the base) is taken from the query
  string.}

\mylst{power.meta}{This implements the staged power function as a
  web service.  The exponent \cd{y} is an early (publish stage)
  argument; but the base \cd{x} is late (serve stage).}

Judging from its prevalence in the literature, we are certain that
millions of grateful users would subscribe to an online service
capable of computing the \emph{power} function!  The screen shot in
figure~\ref{fig:power127} illustrates how it works.  The navigation
bar shows the exponents for which code has been
pre-generated.\footnote{In the current implementation, it is not
  possible for the user to request other exponents once the server is
  running.  See section~\ref{sec:impl} for an explanation.}  After
selecting the exponent, the user types the base into the form and
presses return.  The result is computed using OCaml's
arbitrary-precision \cd{Num} module.  The complete, documented script
appears in listing~\ref{lst:power.meta}.

The user's input is converted to a number relatively late in the
script.  If \cd{num\_of\_string} generates an exception (perhaps
because the user typed non-numeric text into the box), the navigation
bar and form will have already been output before the error message
appears.

In section~\ref{sec:perf}, we will measure the impact of staging on
the scalability of this application.  To derive the un-staged version
for comparison, we simply convert \cd{\Mquote{\Mtilde}} and
\cd{\Mquote{!}} blocks into plain \cd{\Mquote{}} and remove all other
brackets and escapes from the code in listing~\ref{lst:power.meta}.

\subsection{Directory browsing}
\label{sec:eg:browse}

Now we consider a more substantial example.
Many web servers can be configured to permit clients to browse
directories.  The web server generates, on the fly, an HTML page
containing the names and attributes of (and hyperlinks to) all
the files in the directory.  In Apache, the
\texttt{mod\_autoindex} module provides this feature.
%%
ViewCVS\footnote{\url{http://viewcvs.sourceforge.net/}} is a more
complex example of the same idea; it allows remote users to browse a
CVS repository with a standard web browser.

This kind of service can be fairly intense; one HTTP request is likely
to generate dozens of system calls and disk accesses.  If the
directory is viewed more often that it is changed, then it makes sense
to cache or pre-generate the pages.  Although it is simple enough to
write a script to generate directory pages off-line, what if we also
want dynamic behavior, such as user-controlled sorting and filtering?

Our implementation not only lists files in a given directory, but
displays their MD5 checksums, renders their sizes in human-readable
form (`1.2M' rather than `1194822'), and colors their names based on
their extension or file type.  We also support dynamic (serve time)
customization: the user may specify a regular expression for
filtering, and select one of 5 criteria for sorting.  The screen shot
in figure~\ref{fig:server-dir} shows the result of browsing the source
directory of the server itself.

\screenshot{server-dir}{Browsing the server source code directory.
  File names are colored according to their \emph{kind,} which is
  computed from the extension and the file type.  See also
  listing~\ref{lst:dir.meta}.}

This service is a bit like the conference calendar proposed in
section~\ref{sec:intro}.  We pre-generate \emph{everything} that does
not rely on serve-time parameters.  The stats and MD5 sums of the
files are collected \emph{once,} in the publish stage.  The text of
each possible row is prepared in advance.  Once the user's request is
made, we filter and sort the list, then output the pre-generated text
of each remaining row.  The files need not be opened or even
\id{stat(2)}ed while the user is waiting.  Listing~\ref{lst:dir.meta}
contains the complete script, with documentation.

\mylst{dir.meta}{This implements the directory browser shown in
  figure~\ref{fig:server-dir}.} 

Much of the above code is unaffected by staging; functions like
\cd{sort\_by}, \cd{human\_size}, and even \cd{fileinfo} are oblivious
to the stage in which they are run.  Therefore, the staged code comprises a
relatively small portion of the entire program: mainly the function
\cd{list\_files} and its call site.

To understand the staging technique used here, it may help to examine
the output of just the first stage of computation.  The following
listing is cleaned up from the \MOC pretty-printer, with references to
compiled values resolved in-place.

\lgrindfile{dir-out.ml}

The \cd{list} is formed by testing filenames (in reverse alphabetical
order) against the compiled regular expression \cd{rc}, including only
those that match.  The file info record for each file has already
been prepared and appears in the code as a value.

Because the file information is compiled into the code, any changes to
the file system following the first stage of execution will \emph{not}
automatically appear on the web interface.  To see the latest files,
we need to re-run stage one.  This cannot be done from within the \MOC
server page itself, but we have programmed the server to regenerate
pages whenever the `\cd{!}' character is appended to the URI.  The
directory browser pages feature a `Regenerate' button at the bottom
which will bring them up to date by running the publish stage code
again, and caching the result for subsequent requests.



\subsection{Server introspection}

Some web servers can be configured to display their status in response
to certain URIs (such as \id{/server-status} on Apache).  We
programmed a few status services in \MOC.  The screen shot in
figure~\ref{fig:gc} displays garbage collection statistics from the
OCaml \id{GC} module.  The only thing pre-generated here is the
navigation bar.

\screenshot{gc}{Garbage collector statistics.  The descriptions are
  copied directly from the \id{gc.mli} interface in OCaml.}

%\lgrindfile{gc.meta}

\section{Implementation}
\label{sec:impl}


Currently, the \MOC implementation is not capable of reading
and writing \cd{code} values to a file.  This means that
generated server pages (after the publish stage) must already be
in the server memory when it starts.  This is an unfortunate
limitation, as it means we must restart the entire web server to
re-publish any particular page!

A generated server page has this type:

\lgrindfile{codeHandler.mli}

As the server starts, it constructs a dictionary (\cd{code
  StringMap.t}) mapping URIs to code.  This dictionary is
consulted on each HTTP request.  If the URI is not found there,
then we check the file system, in case it refers to a static
file.  If this fails, we respond with a 404 (resource not
found).


\section{Performance}
\label{sec:perf}
One of the benefits of a \emph{compiled} implementation of staged
programming---even byte-code compiled, like \MOC---is that it permits
meaningful measurement.  Here, we describe the performance
characteristics of the prototype, focusing in particular on the
benefits of staging various web services.

The single most important metric for evaluating web server performance
is \textit{throughput:} the number of requests successfully answered
per unit of time.  To establish a baseline, we first tested the
throughput of the Caml prototype HTTP server delivering chunks of
static data of various sizes, up to 64k bytes.
%%
Measurements were taken on an otherwise idle 1.8GHz Intel
Xeon\texttrademark{} workstation\footnote{with 512kB cache, 768MB RAM,
  and Ultra160 SCSI} running Linux 2.4.  We used \texttt{ab},
the Apache HTTP server benchmarking tool, to issue requests
from 8 threads simultaneously for 30 seconds.\footnote{\texttt{ab}
  version 1.3d, available from \url{http://httpd.apache.org/}, 
  invoked like this:
  \texttt{ab -k -t 30 -c 8 }\textit{url}}

\gnuplot{static}{Throughput for static pages.  Note the logarithmic
  scale on the \textit x axis.}

The baseline results are shown in figure~\ref{fig:static}.  The series
marked “Caml file” was served by the \texttt{FileHandler} module.  For
the “Caml code” series, the same files were treated as \MOC Server
Pages, and thus turned into one big \texttt{puts} statement, to be
executed by the \texttt{CodeHandler}.  The only reason the code
wins in the beginning is that all code pages are already loaded into
the server’s memory on startup (to work around a limitation of the
prototype---see section~\ref{sec:impl}), but the \texttt{FileHandler}
must read files from disk each time.

Figure~\ref{fig:static} includes comparable results for PHP, the
popular server-side computation system.\footnote{libphp4.so
  (version 4.3.4) loaded into Apache 1.3} Here, we gave the same
static data files the extension \texttt{.php}, so that Apache
would treat them as PHP code, even though they have no
\cd{\Mquote{}code blocks\Munquote}.
%%
We omitted the results for Apache serving static files, because they
are way off scale: Apache handled an astounding 4,438 hits per second
for the 1k file, and 1,813 for the 64k file.  Apache is heavily
optimized for serving static files: apart from caching, it uses the
special \texttt{sendfile(2)} system call for zero-copy file transfer
from kernel space~\cite{tranter03sendfile}.  Although our prototype is
no match for Apache on static files, the overhead for interpreting
code seems no worse than that of PHP.
%%

Using the same methodology, we now consider the performance of
the staged and unstaged power functions; see
figure~\ref{fig:power}.  The throughput for the staged pages is
about 30\% higher in the beginning, but as the exponents
increase (again, note the log scale in the graph) the gap
narrows.  In this program, staging removes the loop overhead,
but the number of multiplications performed is the same either
way.  Eventually, the cost of those multiplications dominates
everything else.\footnote{The final result,
  2\textsuperscript{8191} has 2,466 digits in base 10!}

\gnuplot{power}{Staged versus unstaged power function.  The
  server page computes 2 to the given power
  (2\textsuperscript{127}, 2\textsuperscript{255}, etc.)}

Finally, we look at the performance of staged and unstaged directory
browsing; see figure~\ref{fig:browse}.  For this task, we created
directories containing a fixed number of files with random data.  The
average file size was 32k.  The \emph{x}~axis shows the number of
files in the directory.  Besides the staging factor, two
implementation languages are compared: we coded the same functionality
in PHP.  The `staged PHP' version must be run first from the command
line; this outputs another PHP script which is then run by the server.

\gnuplot{browse}{Staged versus unstaged directory browsing, in \MOC
  and PHP.}

Directory browsing was the most realistic of the examples, and the
benefit of staging is crystal clear.  In browsing a directory of 64
files, the unstaged programs barely answered 18 requests per second.
They would certainly succumb to the Slashdot effect!

This is exactly the kind of page where the real work needs to be done
in advance.  But that doesn't mean it needs to be a completely static
page, either.  By carefully staging the computation, we gathered the
file information in advance, yet still filtered and sorted the results
on demand.  The staged \MOC directory browser answered more than 550
requests (for the same 64-file directory) per second.

The degradation in performance of the staged PHP version is most
likely due to the fact that the stage two script must be \emph{parsed}
on each request; the size of the script is proportional to the number
of files in the directory.  With \MOC, the code size is also
proportional to the number of files, but the values are already in
memory.  

\section{Related and future work}
\label{sec:related}

Most of the \emph{server page} systems embed programs within web pages
using similar techniques; exemplars include JSP~\cite{sun-jsp},
ASP~\cite{microsoft-asp}, PHP~\cite{bakken04php},
MSP~\cite{elsman03web} (based on SML), and XCaml~\cite{baretta04xcaml}
(based on OCaml).  Ours appears to be the first such language with
explicit support for \emph{staging} the computation.  We inherited the
staging annotations of \MOC~\cite{calcagno03meta} and designed several
new kinds of code blocks based on them.

Unlike more ad-hoc staging methods, \MOC server pages guarantee the
type safety for generated code up front.  We do not, however, make any
guarantees about the validity of the generated HTML.
\citet{elsman04typing}, \citet{wallace99haxml}, \citet{hosoya03xduce},
and \citet{ohl04xhtml} leverage ML-like type systems to validate
(X)HTML generators.  Integrating their ideas into \MOC server pages
may permit validation of the generated document as well.

Our server page language is defined by translation into \MOC.
Unfortunately, this means that error messages refer to the translated
code, not the original, embedded code.  Camlp4 is a flexible
pre-processor capable of modifying the concrete syntax of
OCaml~\cite{rauglaudre03camlp4} while maintaining usable error
messages.  Formulating the server page syntax with Camlp4 would likely
be an improvement over the current, ad-hoc translator.

In motivating \MOC server pages, we observed that the computation
associated with a web page naturally decomposed into three stages:
publish, serve, and display.  Our language, however, was designed to
support just the first two stages.  It is straightforward to imagine
an extension to the third stage (since \MOC itself has no constraints
on the number of stages) but the implementation may be tricky.  First,
we must overcome the process boundary between server and client.  We
currently have no way to export \MOC code blocks from the program that
created them into another program.  (On the server, we circumvented
this limitation by running the publish and serve stages within one
process.)  Next, we need a browser capable of loading and executing
\MOC code.  \citet{rouaix96web} demonstrated a browser called MMM,
written in Caml, that could run applets loaded as Caml byte-code.  It
may be possible to update his browser for use with \MOC, but
developing a plug-in that works with conventional browsers would be
preferable.


One of the major shortcomings of our implementation is that all the
pages must be loaded into memory when the server starts.  Ideally, a
separate tool would translate the server page source directly to
byte-code, stored in an image on disk.  Then the server would map URIs
to these byte-code files, loading and executing them on demand.
Whenever we want to re-run the publish stage, we could do so
independently of the server.  Two limitations of the \MOC
implementation itself appear to stand in the way of this ideal.
First, code values cannot at present be written to or read from files.
Second, code values remain polymorphic until they are \emph{run} with
the \Mrun{} operator.  Therefore, they cannot be passed to functions
or stored in data structures (at least until OCaml supports rank-2
polymorphism).

More substantial applications are needed to demonstrate both the
performance gains and the expressiveness of this approach.  A web
service that uses a database and is spread over several pages would be
more realistic.  \citet{queinnec00influence} and
\citet{graunke01programming} use features of functional languages to
express user interactions more naturally, given the stateless nature
of HTTP.  We suspect that these techniques are orthogonal to the
staging features provided by \MOC.

Finally, although our HTTP implementation stands up to the Apache
benchmarking tool, it is not likely to win any awards for reliability
or flexibility.  Our ideas would likely have greater impact if they
could be implemented as a module for a real server such as Apache or
AOLserver.


\section{Conclusion}
\label{sec:concl}

Web publishing is an important application domain that is
naturally staged.  Web programmers write staged programs every
day, but they do it the old-fashioned way: one script outputs
another as a string.  This is a tremendous opportunity for
multi-stage languages.

We presented the design of \MOC server pages, a new
domain-specific language for web applications programming.  It
leverages the staging annotations of \MOC to provide safe and
precise control over the each stage of the computation.
%%
We have shown the substantial benefits of this approach in terms
of performance and expressiveness, although the prototype
implementation suffers some limitations because it is unable to
read and write generated code to a file.

\section*{Acknowledgments}

Many thanks to the anonymous reviewers of the \MOC workshop, for
helpful recommendations on both the work and the presentation.

\bibliographystyle{abbrvnat}
\raggedright
\bibliography{refs,../../cal}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
