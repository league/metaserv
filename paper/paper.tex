\documentclass[preprint]{acm_proc_article-sp}
\usepackage{ucs,textcomp,url,graphicx,color,listings}
\usepackage[bf]{caption2}
\usepackage[numbers]{natbib}
\usepackage[utf8]{inputenc}
\ifx\pdfoutput\undefined\else
  \usepackage[
    pdfpagemode=None,
    pdftitle={MetaOCaml Server Pages},
    pdfsubject={Web Publishing as Staged Computation},
    pdfauthor={Christopher League}
  ]{hyperref}
\fi
\input{fonts}
\def\MOC{MetaOCaml}
\hyphenation{Meta-OCaml data-base Slash-dot}
\def\quote{\list{}{\leftmargin1.4em\rightmargin1em}\item[]}
\newcommand{\myfig}[3]{%
  \begin{figure}[tbp]%
    #3%
    \caption{#2}%
    \label{fig:#1}%
  \end{figure}}
\newcommand{\screenshot}[2]{%
  \myfig{#1}{#2}
  {\centering%
    \includegraphics[width=20pc,keepaspectratio]{#1}}}
\newcommand{\gnuplot}[2]{%
  \myfig{#1}{#2}{\input{#1}}}
\newcommand{\mylst}[3]{%
  \lstinputlisting[#1 label={lst:#2}, %
    caption={\texttt{#2}.  #3}]{#2}}
\newcommand{\lstfile}{\mylst{}}
\newcommand{\lstfloat}{\mylst{float=htb,}}

\title{\MOC{} Server Pages:}
\subtitle{Web Publishing as Staged Computation}
\numberofauthors{1}
\author{
  \alignauthor Christopher League\\
  \affaddr{Long Island University · Computer Science}\\
  \affaddr{1 University Plaza · Brooklyn, NY 11201}\\
  \email{christopher.league@liu.edu}}
\conferenceinfo{\MOC{} Workshop}{October 2004, Vancouver}
\CopyrightYear{2004}
\toappear{Submitted to the \MOC{} Workshop (Vancouver,
  2004).\\\textbf{Note from author:} Sorry, the exposition gets
  really rough toward the end: too much hacking and not enough 
  writing!  If the PC agrees that this is a worthwhile 
  idea, I'll be happy to fix the paper \emph{ex post
    facto\ldots}} 

\begin{document}
\maketitle
\begin{abstract}
  Modern dynamic web services are really computer programs.
  Some parts of these programs run off-line, others run
  server-side on each request, and still others run within
  the browser.  In other words, web publishing is
  \emph{staged computation,} either for better performance,
  or because certain resources are available in one stage
  but not another.  Unfortunately, the various web
  programming languages target one stage only.  This is a
  tremendous opportunity for multi-stage languages in
  general, and for \MOC{} in particular.
  
  We present the design of \MOC{} Server Pages.  Unlike
  other languages in its genre, the embedded \MOC{} code
  blocks may be annotated with staging information, so that
  the programmer may safely and precisely control which
  computation occurs in which stage.  A prototype web
  server, written in OCaml, supports web sites with both
  static and dynamic content.  We provide several sample
  programs and demonstrate the performance gains won using
  multi-stage programming.
\end{abstract}
\category{D.3.2}{Programming Languages}{Language
  Classifications}[Specialized application languages]
\category{H.3.5}{Information Storage and Retrieval}{Online Information
  Services}[Web-based services]

\vfill
\section{Motivation}
\label{sec:intro}

In their infancy (ca.~1993), web sites were little more than
clickable FTP sites with in-line images.  They enabled
distribution of static documents, but did little to enhance
collaboration or create a sense of community.  In contrast,
today's users expect most web sites to offer sophisticated
services and to permit endless personalization.  In 2004,
even a strictly personal web site is expected to incorporate
user-contributed content such as comments and ratings.
\newpage

To provide such features, web sites contain custom computer
programs.  \citet{greenspun99panda}, in his insightful web
publishing guide book, describes the situation like this:

\begin{quote}
  You needn’t turn your site into a program just because the
  body of material that you are publishing is changing.
  Sites like Yahoo, for example, are sets of static files
  that are periodically generated by programs grinding
  through a dynamic database.  With this sort of
  arrangement, the site inevitably lags behind the database,
  but you can handle millions of hits a day without a major
  investment in computer hardware, custom software, or
  thought.\par If you want to make a collaborative site,
  however, then at least some of your web pages will have to
  be computer programs.  Pages that process user submissions
  have to add user-supplied data to your web server’s disk.
  Pages that display user submissions have to look through a
  database on your server before delivering the relevant
  contributions.~\cite[page 271]{greenspun99panda}
\end{quote}

In some notable ways, programming for the web is different
from programming in other domains.  Interaction design is
more of a challenge: in part because HTTP is stateless, but
also because users want to hit the `back' button and to set
bookmarks into the middle of
a carefully designed sequence of dialogs.%
\footnote{\citet{queinnec00influence} and
  \citet{graunke01programming} examine language-based
  approaches to solving this particular
  problem.} %
And unlike with shrink-wrapped applications, on the web it
is possible (though not always desirable) to ``go live''
immediately with a new fix or feature.

Nevertheless, there is at least one dictum of program design
that we cannot escape on the web: \emph{performance
  matters.}  As a web publisher, visitors are your bread and
butter.  But will your servers and scripts be ready for the
day that your site is featured on prime time television, or
on \texttt{slashdot.org}?  If tens of thousands of potential
users drop by to find a sluggish (or dead) server, most of
them will never return.

This happens so often to sites featured on Slashdot---a
``news for nerds'' discussion site---that it has come to be
known as the \emph{Slashdot effect:} ``a site that might be
designed to handle a few hundred hits per day can suddenly
find itself handling that many a
second.''~\cite{turner03slashdot}~ Although some ISPs have
bandwidth limitations, Slashdot creator Rob Malda says most
sites that fall suffer from poor planning and architecture:
\begin{quote}
  The problem is, if you have any sort of complicated code
  on your page, that’s what kills people. I generally think
  that sites are not dying because they fill their pipe, but
  because they have poorly written code.
  
  As a general rule, anybody who has a pretty good
  understanding of web design, they’ve done a good job of
  learning what information to cache. What information needs
  to be pregenerated. So when you’re actually loading a
  page, even if it’s a complicated page that looks dynamic
  and custom, on the back end of that, what they’re really
  doing is putting together a bunch of puzzle pieces that
  have been pregenerated, and making the simplest, quickest
  decisions they possibly can.~\cite{turner03slashdot}
\end{quote}

Both of the preceding quotes point (informally) to the idea
of \emph{staging} the computation performed by a web
service.  Indeed, web publishing is an application area that
is naturally staged;\footnote{Nevertheless, it seems the
  literature on meta-programming has not yet acknowledged
  web services as a potential application area, although
  \citet{sheard01accomp} does
  mention \emph{mobile code.}} %
to wit:
\begin{enumerate}
\item Content (text, images, programs, etc.) created
  off-line is uploaded to the server---the \emph{publish}
  stage;
  
\item A user's browser requests content, which is
  transferred from server to client---the \emph{serve}
  stage; and finally
  
\item The content is rendered within the user's
  browser---the \emph{display} stage.
\end{enumerate}
At \emph{each} stage there is an opportunity for computation
to take place.  Consider the example of a conference
calendar, such as the one illustrated in
figure~\ref{fig:confcal}.  After specifying your areas of
interest (perhaps using the ACM classifications), the server
delivers a table of matching conferences, with dates,
locations, deadlines, and links to conference web sites.
Events remain in the table until a few weeks after they
occur, but deadlines that have passed are marked in red.
You may click on any column header to change the sort order.
The next time you visit, the server remembers your
preferences.  Perhaps it even sends you email to remind you
of upcoming submission and registration deadlines.

\screenshot{confcal}{A simple conference calendar, implemented as a
  PHP script that connects to a PostgreSQL database.  Not as
  sophisticated as the service described in the text.}

Now, how might this conference service be staged?  Can
anything be computed off-line (at the \emph{publish} stage)?
Yes!  Since this page is probably part of a much larger site
(whose structure does not change every day), the menus and
other navigation aids can be laid out in advance.  We will
not know which conferences to display until the user
presents some identification (in the form of a `cookie'),
but since the conference data changes infrequently, it may
help to prepare the text of each row in advance.

During the \emph{serve} stage, we look up the user's topic
preferences, and ship out just the matching rows.  We delay
sorting the table until the \emph{display} stage.  The user
ought to be able to adjust the sort criteria without any
further communication with the server.  What about marking
past dates in red?  If this is also delayed until display,
then the code could be cached client-side for long periods
of time, yet still behave dynamically.

At this point, we should emphasize the importance of
\emph{profiling} in developing scalable web services.  This
particular design for the conference calendar may not be
optimal, depending on the relative speeds of the CPU,
memory, database, network, and disk.  Rather, our aim is to
provide a single language in which the various staging
possibilities can be expressed naturally.

This is in stark contrast to the status quo, where each
system targets one stage only.  The Website Meta Language
(WML) \cite{engelschall-wml} is an ``off-line HTML
generation toolkit'' designed for the \emph{publish} stage.
But many other programs (and countless ad-hoc scripts) spit
out HTML pages: think of \LaTeX2HTML.  Google
reports surprisingly many
programs\footnote{\url{http://google.com/search?q=gedcom+generate+html}}
for creating family tree web sites from genealogy database
files; these count as publish-stage tools.

The \emph{serve} stage is well-served by the ``server page''
languages, including JSP~\cite{sun-jsp},
ASP~\cite{microsoft-asp},
MSP~\cite{elsman03web}, and
PHP~\cite{bakken04php}.  The CGI protocol~\cite{w3c-cgi}
addresses the \emph{serve} stage, as do the embedded
interpreters (such as \texttt{mod\_perl} and
\texttt{mod\_python} for Apache) that exist to ameliorate some
of the overhead of CGI.
%%
There is, relatively, a paucity of languages that operate
client-side (\emph{display} stage), probably due to the
difficulty of securing an installed base of interpreters.
JavaScript~\cite{netscape-javascript} and Java applets are
notable exceptions.

Imagine implementing the conference calendar, as conceived
above, using currently deployed technology: A Perl script
outputs a PHP page which contains JavaScript!  Values are
passed from one stage to the next as strings, and the
programmer must manage all the quoting and persistence
issues by hand.

We present ``\MOC{} server pages,'' a new domain-specific
language for web applications programming.  It leverages the
staging annotations of \MOC~\cite{calcagno03meta,taha00metaml}
to provide safe and precise control over the each stage of the
computation.  We have implemented the system in two parts: our
translator transforms the server page language into a \MOC{}
module, which then can be incorporated into our multi-threaded
HTTP 1.1 server (also written in \MOC{}).  The scalability
gained by staging certain applications is stunning.

The next section sketches the design and translation of \MOC{}
server pages, and section~\ref{sec:eg} includes some non-trivial
examples.  The server implementation is decribed in
section~\ref{sec:impl}.  Performance and scalability are
discussed in section~\ref{sec:perf}

\section{Design}
\label{sec:design}

The general idea of a \emph{server page} language is that we
  write HTML by default, and embed code %
\lstinline{<?like this?>}.  %
PHP programmers are familiar with this syntax for embedding code, but
in our case, the code itself is written in \MOC.  Here is your first
\MOC{} server page:

\lstinputlisting{first.meta}
and its output:
\begin{quote}
  \textit{Hello,} \textbf{Unhandled exception: Failure("Nice try!")}
\end{quote}
If a code block raises an exception, the message is sent to the
client's browser in bold-face, and the rest of the page is
aborted. 

\def\cd#1{\lstinline{#1}}
\def\id#1{\texttt{#1}}

A very common use of code blocks is to print out (i.e., send to
the browser) the result of evaluating some expression.  The
syntax \cd{<?= e?>} is designated for this task; \cd{e} must
have type \id{string}.  Alternatively, messages may be formatted
with \id{printf} by placing the format string immediately after
the code delimiter: \lstinputlisting{pi.meta}
\begin{quote}
  ........ $\pi$ ÷ 008 is 0.3927
\end{quote}
In a departure from the standard OCaml syntax for \id{printf}, the
arguments are comma-delimited.
%%
One more kind of code delimiter is used for \emph{declarations;}
these are evaluated during the publishing stage:
\lstinputlisting{perm.meta}
\begin{quote}
Permissions on current directory are 0755
\end{quote}

Once published, this output will never change!  The \id{stat}
call is executed only once, not on each request.

To see how all this works, let's consider how a \MOC{} server
page is translated into a proper \MOC{} program, to be executed
at publish time.  Since the program is executed before any
browser has requested the page, it cannot directly return or
output HTML.  Instead, it will construct and return a \id{code}
object which is subsequently run on each request (serve stage).
Listing~\ref{lst:trans.meta} shows a sample \MOC{} server page,
and listing~\ref{lst:trans.ml} contains its translation.

\lstfloat{trans.meta}{This file demonstrates the various
  kinds of code blocks.}%
\begin{lstlisting}[language={[Objective]Caml},
  label={lst:trans.ml}, float=htb, 
  caption={\texttt{trans.ml}.  This is the translation of the
    page in listing~\ref{lst:trans.meta}.  Declarations have
    been lifted, and everything else appears within
    \lstinline{.<brackets>.}}]
module Trans = struct
  let lift x = .<x>.
  (* Declarations *)  
  (* More declarations *) 
  let page  = .<fun req puts -> (*@\label{line:page}@*)
    let arg = Request.arg req in 
    (* Code *) ;
    puts ( (* String to be printed *) );
    puts "Regular text.\n";
    Printf.kprintf puts "format string" ( a )  ( b )  ( c ) ;
    let x = (* Expression *) in (*@\label{line:in}@*)
    (* More code *) ;
    puts "Bye!\n";>.
end
\end{lstlisting}

Declaration blocks have been lifted to the top; any side effects
contained there are executed when the page is published.  The
constructed code begins on line~\ref{line:page} of
listing~\ref{lst:trans.ml}.  It is a function of two arguments:
\cd{req} encapsulates the HTTP request, including the headers
and query arguments; \cd{puts} is a function with type
\cd{string->unit}; it transmits text across the network to the
visitor's browser.  \cd{arg} looks up an
argument in the query string of the request; its type is
\cd{string->string option}.  These are all \emph{serve} (second)
stage values.  It makes no sense to access them in the
\emph{publish} (first) stage, and indeed the \MOC{} type system
prevents this.

A few finer points to note: the translator discards newlines that
immediately follow code blocks (otherwise,
listing~\ref{lst:trans.ml} would be dotted with %
\lstinline{puts "\n"} statements).  It automatically follows
code blocks with either a semi-colon or the \lstinline{in}
keyword, as needed.

Now that we understand how the server page is assembled into a
staged program, the effects of adding \MOC{} staging operators
to our pages should be predictable.  Below is a reformulation of
the permissions example, using escape \cd{.~} and \cd{lift} to
ensure that \id{stat} is called only once.
\lstinputlisting{perm2.meta}
%%
Still, the \id{printf} conversion is performed at serve time, so
maybe it is best to pre-generate that as well:
\lstinputlisting{perm3.meta}
Now, all that remains to execute at serve time is %
\cd{puts "0755"}.  Finally it is possible to splice in
additional code at publish time, such as in this count-down
example:
\lstinputlisting{count.meta}
It removes the loop overhead by expanding to a sequence of 99
\cd{puts} statements.

These tiny examples illustrate some of the common uses of the
escape operator, for which we developed syntactic sugar:

\begin{tabular}{l@{\quad$\leadsto$\quad}l}
\cd{<?~ a ?>} &
\cd{<? .~( a ) ?>}
\\
\cd{<?~= b ?>} &
\cd{<?= .~( b ) ?>}
\\
\cd{<?~let x = c ?>} &
\cd{<?let x = .~( c ) ?>}
\\
\cd{<?~"fmt" d, e, f?>} &
\cd{<?"fmt" .~(d), .~(e), .~(f)?>}
\end{tabular}

where the \cd{a} has type \cd{unit code}; \cd{b} has type
\cd{string code}; and the types of \cd{d,e,f} match the
format string.

One last feature in the design of \MOC{} server pages is the ability
to take publish-stage arguments.  The parameter names are specified to
the translator in a \emph{pragma} declaration, which can appear
anywhere in the code:
\begin{lstlisting}[numbers=none]
  <?pragma args x y z ?>
\end{lstlisting}
The translator inserts these as page parameters, like this:
\begin{lstlisting}[numbers=none, language={[Objective]Caml}]
  let page x y z = .< ... >.
\end{lstlisting}
Now the code can be instantiated with early parameters in countless
ways.  For example, requesting the URI \id{/longcount} could print a
count-down from 99, while \id{/shortcount} starts at 9 instead.  Both
are generated from the same server page.  Mapping from URIs to
instantiated \MOC{} code is, for now, an implementation detail
(see \S\ref{sec:impl}).

\section{Examples}
\label{sec:eg}

To explore the expressiveness of this design, we now look at a
series of web services, organized to comprise a small web
site.\footnote{I hope to make the demo available on the web in time
  for the workshop; this will require convincing the I.T. folks to
  open up a non-standard port through the firewall.  For now, it may
  be downloaded and run locally.} %
To give the services a similar look, we developed a site-wide style
sheet, and an OCaml function to generate a navigation bar from a
hierarchical list of page titles and links.  The following bindings are
available site-wide:
\begin{lstlisting}[numbers=none]
  val preamble: string -> string
  val navbar: string -> string
  val postamble: string
\end{lstlisting}
The first function generates the standard XHTML header given the
title, while the second function generates the navigation bar given
the URI denoting the current page.  These can be called at either
stage.  Naturally, if the title includes a dynamic argument, then
\cd{preamble} will be delayed until the serve stage.

\subsection{The ubiquitous power function}
\label{sec:eg:power}

Judging from its prevalence in the literature, we are certain that
millions of grateful users would subscribe to an online service
capable of computing the \emph{power} function!  The screen shot in
figure~\ref{fig:power127} illustrates how it works.  The navigation
bar shows the exponents for which code has been pre-generated.  It is
not possible, with the current implementation, for the user to request
other exponents (see \S\ref{sec:impl} for an explanation).  After
selecting the exponent, the user types the base into the form and
presses return.  The result is computed using OCaml's
arbitrary-precision \id{Num} module.  The implementation of this
service appears in listing~\ref{lst:power.meta}.

\screenshot{power127}{Web browser displaying the result of
  7\textsuperscript{127}.  The URI \texttt{/power127} maps to code
  where the early argument (the exponent) has been set to 127, and the
  late argument (\texttt{x}, the base) is taken from the query
  string.}

\lstfile{power.meta}{This implements the staged power function as a
  web service.  The exponent \cd{y} is an early (publish stage)
  argument; but the base \cd{x} is late (serve stage).}

The first function wraps a string into a fixed width block.  The power
function itself begins on line~\ref{line:power-fun}.  No output should
occur until the preamble is generated on
line~\ref{line:power-preamble}.  The user's input is translated to a
number relatively late (line~\ref{line:power-num}); if there is a
problem here, the navigation bar and form will have already been
output before the exception message.

In section~\ref{sec:perf}, we will measure the impact of staging on
the scalability of this service.  To derive the un-staged version for
comparison, we simply remove all the brackets and escapes from the
code in listing~\ref{lst:power.meta}.

\subsection{Directory browsing}
\label{sec:eg:browse}

Many web servers can be configured to permit clients to browse
directories.  The web server generates, on the fly, an HTML page
containing the names and attributes of (and hyperlinks to) all
the files in the directory.  In Apache, the
\texttt{mod\_autoindex} module provides this feature.

ViewCVS is a more complex example of the same idea.  It is a
Python program that sits on the web server and allows remote
users to browse a CVS repository with a standard web browser.

This kind of service can be fairly intensive; a single HTTP
request is likely to generate dozens of system calls and disk
accesses.  If the directory is viewed more often that it is
changed, then it makes sense to cache or pre-generate the pages.
It's simple enough to write a script to generate directory pages
off-line, but what if we also want dynamic user-controlled
behavior, such as sorting and filtering?

Our contribution to the genre not only lists files in a given
directory, but displays their MD5 checksums, renders their sizes
in human-readable form (140k or 1.2M), and colorizes their names
based on their extension or kind.  At serve time, the user may
specify a regular expression for filtering, and one of 5
criteria for sorting.  The screen shot in
figure~\ref{fig:server-dir} shows the result of browsing the
source directory of the server.

\screenshot{server-dir}{Browsing the server source code directory.}

This service is a bit like the conference calendar outlined in
section~\ref{sec:intro}.  Everything that can be pre-generated
\emph{is.}  At serve time, we just compile the regular expression,
then filter and sort the data (unless the default order was chosen).
The text of each row is ready and waiting.  At serve time, the files
need not be opened or even \id{stat}ted.  The crux of the
implementation is shown in listing~\ref{lst:dir.meta}:

\mylst{lastline=39,}{dir.meta}{Implementation of directory
  browsing service.  This is the page part; some top-level
  declarations were omitted.  See also
  listing~\ref{lst:dir.meta-2}.}

We omitted some of the more mundane functions on this page, but
\cd{list_files} is important, so it appears in
listing~\ref{lst:dir.meta-2}.  In the first stage, this reads
all the filenames in the directory and sorts them by name.  Then
it looks up the fileinfo, computes the MD5 sum, and prepares the
text of each row.  Finally, it generates code that matches the
filename against a (future-stage) regular expression, and
includes it in a list only if it matches.  In the next stage,
this list will be constructed and sorted (if necessary).  

\mylst{}{dir.meta-2}{This top-level function transforms a list
  of filenames into a code sequence that tests each name against
  a regexp, and adds it to the list only in the case of a
  match.}

\subsection{Server introspection}

Some web servers can be configured to display their status in
response to certain URIs (such as \id{/server-status} on
Apache).  We programmed a few status services in \MOC.  The
screen shot in figure~\ref{fig:gc} displays garbage collection
statistics from the OCaml \id{GC} module.

\screenshot{gc}{Garbage collector statistics.}

The only complicated bit in the code is to format the numbers
using commas every three digits.  The descriptions are copied
directly from the \id{gc.mli} interface in OCaml.  The only
thing pre-generated here is the navigation bar (line 2).

\mylst{lastline=30,}{gc.meta}{...}

\section{Implementation}
\label{sec:impl}


Currently, the \MOC{} implementation is not capable of reading
and writing \id{code} values to a file.  This means that
generated server pages (after the publish stage) must already be
in the server memory when it starts.  This is an unfortunate
limitation, as it means we must restart the entire web server to
re-publish any particular page!

A generated server page has this type:
\begin{lstlisting}[numbers=none]
  type code = Request.req -> (string -> unit) -> unit
\end{lstlisting}
As the server starts, it constructs a dictionary (\cd{code
  StringMap.t}) mapping URIs to code.  This dictionary is
consulted on each HTTP request.  If the URI is not found there,
then we check the file system, in case it refers to a static
file.  If this fails, we respond with a 404 (resource not
found).


\section{Performance}
\label{sec:perf}

One of the benefits of a \emph{compiled} implementation of staged
programming---even byte-code compiled, like \MOC{}---is that it
permits meaningful measurement.  Here, we describe the performance
characteristics of the prototype, focusing in particular on the
benefits of staging the computations performed by various web
services.

The single most important datum for evaluating web server performance
is \textit{throughput:} the number of requests successfully answered
per unit of time.  To establish a baseline, we first tested the
throughput of the Caml prototype HTTP server delivering chunks of
static data of various sizes, up to 64k bytes.
%%
Measurements were taken on an otherwise idle 1.8GHz Intel
Xeon\texttrademark{} workstation\footnote{with 512kB cache, 768MB RAM,
  and Ultra160 SCSI} running Linux 2.4.  We used \texttt{ab},
the Apache HTTP server benchmarking tool, to issue requests
from 8 threads simultaneously for 30 seconds.\footnote{\texttt{ab}
  version 1.3d, available from \url{http://httpd.apache.org/}, 
  invoked like this:
  \texttt{ab -k -t 30 -c 8 }\textit{url}}

\gnuplot{static}{Throughput for static pages.  Note the logarithmic
  scale on the \textit x axis.}

The baseline results are shown in figure~\ref{fig:static}.  The
series marked “Caml file” was served by the \texttt{FileHandler}
module.  For the “Caml code” series, the same files were treated
as \MOC{} Server Pages, and thus turned into one big
\texttt{puts} statement, executed by the \texttt{CodeHandler}
module.  The only reason the code wins in the beginning is that
all code pages are already loaded into the server’s memory on
startup (to work around a limitation of the prototype---see
sections~\ref{sec:impl} and~\ref{sec:future}), but the
\texttt{FileHandler} must read files from disk each time.

Figure~\ref{fig:static} includes comparable results for PHP, the
popular server-side computation system.\footnote{libphp4.so
  (version 4.3.4) loaded into Apache 1.3} Here, we gave the same
static data files the extension \texttt{.php}, so that Apache
would treat them as PHP code, even though they have no
\lstinline{<?code blocks?>}.
%%
We omitted the results for Apache serving static files, because they
are way off scale: Apache handled an astounding 4,438 hits per second
for the 1k file, and 1,813 for the 64k file.  Apache is heavily
optimized for serving static files: apart from caching, it uses the
special \texttt{sendfile()} system call for zero-copy file transfer
from kernel space~\cite{tranter03sendfile}.  Although our prototype is
no match for Apache on static files, the overhead for interpreting
code seems no worse than that of PHP.
%%

Using the same methodology, we now consider the performance of
the staged and unstaged power functions; see
figure~\ref{fig:power}.  The throughput for the staged pages is
about 30\% higher in the beginning, but as the exponents
increase (again, note the log scale in the graph) the gap
narrows.  In this program, staging removes the loop overhead,
but the number of multiplications performed is the same either
way.  Eventually, the cost of those multiplications dominates
everything else.\footnote{The final result,
  2\textsuperscript{8191} has 2,466 digits in base 10!}

\gnuplot{power}{Staged vs.\@ unstaged power function.  The
  server page computes 2 to the given power
  (2\textsuperscript{127}, 2\textsuperscript{255}, etc.)}

Finally, we look at the performance of staged and unstaged
directory browsing; see figure~\ref{fig:browse}.  For this task,
we created directories containing a fixed number of files with
random data.  The average file size was 32k.  The \emph{x}~axis
shows the number of files in the directory.  

\gnuplot{browse}{Staged vs.~unstaged directory browsing.  *The
  Apache results refer to \texttt{mod\_autoindex}; it does
  \emph{not} compute the MD5 sum.}

Directory browsing was the most realistic of the examples, and
the benefit of staging is crystal clear.  In browsing a
directory of 64 files, the unstaged program barely answered 18
requests per second.  It would certainly succumb to the Slashdot
effect!

This is exactly the kind of page where the real work needs to be
done in advance.  But that doesn't mean it needs to be a
completely static page, either.  By carefully staging the
computation, we gathered the file information in advance, yet
still filtered and sorted the results on demand.  The staged
directory browser answered more than 550 requests (for the same
64-file directory) per second.

Figure~\ref{fig:browse} also includes the performance of
Apache's directory browser, \texttt{mod\_autoindex}.  It cannot
keep up with the staged browser, even though it doesn't compute
the MD5 sum or filter the files on demand.

\section{Related work}
\label{sec:related}

We already referenced the other systems for server-side
computation, but we would be remiss without mentioning
XCaml~\cite{baretta04xcaml}\ldots

For client-side computation, besides JavaScript and Java
applets, there is the work by \citet{rouaix96web} on Caml
applets.  It may be possible to update his MMM browser for use
with \MOC{}, but we would prefer to use a plug-in approach that
works with mainstream browsers\ldots

\citet{elsman04typing}, \citet{wallace99haxml},
\citet{hosoya03xduce}, and \citet{ohl04xhtml} validate HTML code
in functional languages.  We could probably use OCaml's type
system to greater advantage this way, but it may require
validating the text parts of the server page with a more
mainstream SGML or XML validator.

\newpage
\section{Future directions}
\label{sec:future}

\begin{itemize}
  
\item This really needs to be a module for a real server, such
  as Apache or AOLserver.
  
\item Need more serious case studies, where one logical service
  is implemented across a series of pages.
  
\item Need to address the major implementation shortcoming, of
  loading all the generated pages into memory on startup.
  
  Marshalling closures works partly in OCaml, but only if they
  are part of the ``original program''---that's probably too
  limiting for our case.  The abstract syntax representation of
  code values could be dumped to a file, but the `persistent'
  functions it refers to will need to be stored somewhere\ldots

\end{itemize}


\section{Conclusion}
\label{sec:concl}

Web publishing is an important application domain that is quite
naturally staged.  Web programmers write staged programs every
day, but they do it the old-fashioned way: one script generates
another as a string.  This is a tremendous opportunity for
multi-stage languages.

We presented the design of \MOC{} server pages, a new
domain-specific language for web applications programming.  It
leverages the staging annotations of \MOC{} to provide safe and
precise control over the each stage of the computation.

We have shown the substantial benefits of this approach in terms
of performance and expressiveness, although the prototype
implementation suffers some limitations because it is unable to
read and write generated code to a file.


\bibliographystyle{abbrvnat}
\raggedright
\bibliography{refs,../../cal}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
