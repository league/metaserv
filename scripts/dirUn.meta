<?pragma args d ?>
<?^open Printf
   open Unix
   open List
 ?>
<html>
  <head>
    <title>Directory <?=d?></title>
    <link href="meta.css" rel="stylesheet" type="text/css" />
  </head>
<body>

<?^let default_regex = (".*", Str.regexp ".*") ?>
<? let (re,rc) = match arg "re" with
       None -> default_regex
     | Some r -> (r, Str.regexp r) 
 ?>
<? let list = list_files d rc ?>
<? let list = sort_by (arg "ord") list ?>


<h1>Contents of &lsquo;<?=d?>&rsquo;</h1>
<?"%d" length list?> files 

<?^let rec ord_options puts ord opts =
     match opts with
       [] -> .<()>.
     | (tag,text)::opts ->
         .<(kprintf .~puts "<option %s value=\"%s\">%s</option>\n"
              (if .~ord = tag then "selected" else "")
              tag text;
           .~(ord_options puts ord opts))>.
 ?>
<? let ord = match arg "ord" with
       None -> "name"
     | Some o -> o
 ?>

<form method="get" action="">
Order:
  <select name="ord">
    <?~ord_options .<puts>. .<ord>.
         ["name", "Name";
          "ext",  "Extension";
          "time", "Timestamp";
          "size", "Size";
          "kind", "Kind"]
     ?>
  </select>
Filter: 
  <input type="text" name="re" size="14" value="<?=re?>" />
  <input type="submit" value="Redisplay" />
</form>

<pre>
<?=header?>
<? iter (fun f -> puts f.prn) list ?>
</pre>
<hr/>
MetaOCaml <?=Sys.ocaml_version?>

</body>
</html>

<?^ (*******************************************************************)

type fileinfo =
    { name: string;
      ext: string;
      kind: string;
      mtime: float;
      size: int;
      md5: string;
      prn: string
    }

let sort_by order list = match order with
    Some "ext"  -> stable_sort (fun f1 f2 -> compare f1.ext f2.ext) list
  | Some "kind" -> stable_sort (fun f1 f2 -> compare f1.kind f2.kind) list
  | Some "time" -> stable_sort (fun f1 f2 -> compare f1.mtime f2.mtime) list
  | Some "size" -> stable_sort (fun f1 f2 -> compare f1.size f2.size) list
  | _ -> list

  let human_size n = 
    if n < 1024 then sprintf "%4d " n
    else if n < 102400 then sprintf "%4.1fk" (float_of_int n/.1024.)
    else if n < 1024000 then sprintf "%4dk" (n/1024)
    else if n < 104857600 then sprintf "%4.1fM" (float_of_int n/.1048576.)
    else sprintf "%4dM" (n/1048576)

  let entry_fmt = format_of_string
"<span class=\"md5\">%-32s</span>  %-29s  %5s  <span class=\"%s\">%s%s</span>\n"
  let header = sprintf
      "<b>%-32s  %-29s  %-5s  %s</b>\n"
      "checksum" "modification time" "size" "name"

  let fileinfo d name =
 (* printf "%s\n%!" name; *)
    let path = Filename.concat d name in
    let st = stat path in
    let md5 = 
      if st.st_kind = S_REG 
      then Digest.to_hex (Digest.file path)
      else "" in
    let ext = 
      try let i = String.rindex name '.' + 1 in
          Str.string_after name i
      with Not_found -> "" in
    let (kind, indicator) = 
      match st.st_kind with
      | S_DIR  -> ("dir", "/")
      | S_LNK  -> ("symlink", "@")
      | S_FIFO -> ("fifo", "|")
      | S_SOCK -> ("sock", "=")
      | S_CHR  -> ("cdev", "")
      | S_BLK  -> ("bdev", "")
      | S_REG ->
          let k =
            match ext with
            | "a"   -> "lib"
            | "cma" -> "lib"
            | "cmi" -> "obj"
            | "cmo" -> "obj"
            | "ml"  -> "src"
            | "mli" -> "hdr"
            | _ -> "" in
          let i =
            if st.st_perm land 0o111 = 0 then "" else "*" in
          match (k,i) with
          | ("", "*") -> ("exe", "*")
          | other -> other in
    let prn = 
      sprintf entry_fmt md5
        (TimeStamp.format st.st_mtime) 
        (human_size st.st_size)
        kind name indicator
    in
    {name=name; ext=ext; kind=kind;
      mtime=st.st_mtime; size=st.st_size;
      prn=prn; md5=md5}

let cmp x y = - (compare x y)

let rec read_all dh files = 
  try read_all dh (readdir dh :: files)
  with End_of_file ->
    closedir dh;
    sort cmp files

let list_files d re =
  let rec loop term files =
    match files with
      [] -> term
    | name::files ->
          let list =
            try ignore(Str.search_forward re name 0);
                (fileinfo d name) :: term
            with Not_found -> term
          in loop list files in
  loop [] (read_all (opendir d) [])

 ?>
